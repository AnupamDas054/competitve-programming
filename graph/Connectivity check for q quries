/*
GeeksforGeeks
Given an undirected graph consisting of N vertices and M edges and queries Q[][] of the type {X, Y}, the task is to check if the vertices X and Y are in the same connected component of the Graph.

Input: Q[][] = {{1, 5}, {3, 2}, {5, 2}} 
Graph: 
 

1-3-4   2
  |
  5   

Output: Yes No No 

Input: Q[][] = {{1, 9}, {2, 8}, {3, 5}, {7, 9}} 
Graph: 

1-3-4  2-5-6  7-9
       |
       8   

Output: No Yes No Yes 

Time Complexity: O(N + M + sizeof(Q)) 
Auxiliary Space: O(N)

Idea: run dfs for each unvisited vertex and make the parent of each vertex of a component same as the starting vertex.
*/


#include<bits/stdc++.h>
using namespace std;

vector<int>adj[100000];
bool visited[100000];
int parent[100000];

void dfs(int index,int starting_vertex)
{
    if(visited[index])
        return ;
    visited[index]=1;
    parent[index]=starting_vertex;

    for(int adj_vertex:adj[index])
    {
        dfs(adj_vertex,starting_vertex);
    }
}

int main()
{
    int n,m;cin>>n>>m;
    for(int i=0;i<m;i++)
    {
        int a,b;cin>>a>>b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    for(int i=1;i<=n;i++)
    {
        if(!visited[i])
        {
            dfs(i,i);
        }
    }
    int query;cin>>query;
    for(int i=0;i<query;i++)
    {
        int a,b;cin>>a>>b;
        if(parent[a]!=parent[b])
        {
            cout<<"NO"<<endl;
        }
        else
            cout<<"Yes"<<endl;
    }
}


//another solution using union find .......see gfg: https://www.geeksforgeeks.org/queries-to-check-if-vertices-x-and-y-are-in-the-same-connected-component-of-an-undirected-graph/
