/*

Spoj: Dquery 


Given a sequence of n numbers a1, a2, ..., an and a number of d-queries. A d-query is a pair (i, j) (1 ≤ i ≤ j ≤ n). For each d-query (i, j), you have to return the number of distinct elements in the subsequence ai, ai+1, ..., aj.


input
5
1 1 2 1 3
3
1 5
2 4
3 5

Output
3
2
3 

complexity: O((N+q)*sqrt(N))

help : codencode

*/


#include<bits/stdc++.h>

using namespace std;
int n,q,cnt,block;
int arr[200001],ans[200002],fre[2000001];

struct query{
   int l,r,i;
};
query Q[200001];


bool cmp(query a, query b)
{
    if(a.l/block != b.l/block)
        return a.l/block < b.l/block;
    return a.r<b.r;
}

void add(int pos)
{
  fre[arr[pos]]++;
  if(fre[arr[pos]]==1)
    cnt++;
}

void remove(int pos)
{
    fre[arr[pos]]--;
    if(fre[arr[pos]]==0)
        cnt--;
}


int main()
{

    ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    cin>>n;
    block=sqrt(n)+1;
    for(int i=0;i<n;i++)
        cin>>arr[i];
        
    cin>>q;
    for(int i=0;i<q;i++)
    {
        cin>>Q[i].l>>Q[i].r;
        Q[i].i=i,Q[i].l--,Q[i].r--;
    }
    
    sort(Q,Q+q,cmp);
    
    int ML=0,MR=-1;
    for(int i=0;i<q;i++)
    {
        int L=Q[i].l;int R=Q[i].r;
        while(ML>L)
            ML--,add(ML);
        while(MR<R)
            MR++,add(MR);
        while(ML<L)
            remove(ML),ML++;
        while(MR>R)
            remove(MR),MR--;

        ans[Q[i].i]=cnt;

    }
    
    for(int i=0;i<q;i++)
        cout<<ans[i]<<"\n";


}








